---
nav_order: 1.1
---

# Как работает эта библиотека

Данный раздел не обязательный для изучения, но крайне полезный.

## Основные термины

### Зависимость (dependency)

Это то что требуется получить, каждая зависимость имеет название (name, или id, или key).

По имени можно получить значение любого типа (mixed), например:

1. Различные параметры (строковые, числовые и тд), например DB_USERNAME - root имя пользователя бд
2. Другие объекты, например \PDO - экземпляр класса подключения к бд

Для создания экземпляра могут требоваться аргументы, например для создания \PDO:
dsn, username, password, options.  
Эти аргументы в свою очередь тоже являются зависимостями

Цепочка зависимостей может быть любой длинны, например для регистрации пользователя (RegisterHandler) может 
потребоваться подключение к БД (\PDO) которому в свою очередь требуются свои зависимости и тд.

Иногда аргументом для создания объекта может требоваться объект реализующий interface, это тоже зависимость.

В некоторых случаях одна и та же зависимость может использоваться в разных местах, например для 
регистрации пользователя (RegisterHandler) и аутедентификации пользователя (AuthHandler) может потребоваться 
подключение к бд (\PDO) или инструмент логирования \Psr\Log\LoggerInterface.

### [Container](https://github.com/cekta/di/src/Container.php)

Это объект который на основе имени получает зависимость, при необходимости создавая ее, реализует
[ContainerInterface из PSR-11](https://www.php-fig.org/psr/psr-11/).

Контейнер сам не занимается загрузкой dependency он лишь определяет какой провайдер может ее загрузить, 
передавая управления ему, по сути Container реализует стратегию(pattern) по выбору подходящего провайдера.

Если два провайдера могут загрузить одну зависимость, используется тот что был передан раньше.

При создании контейнера можно передать любое количество провайдеров.

### Провайдер (Provider)

Занимается получение зависимостей, объекты реализуют 
[ProviderInterface](https://github.com/cekta/di/src/ProviderInterface.php). 

В комплекте с библиотекой идет необходимый набор провайдеров, которые предоставляют основные возможности вам остается 
их лишь настроить.

Вы можете создавать свои провайдеры или расширять существующие

Провайдеры могут возвращать **загрузчики**.

### Загрузчик (Loader)

Объекты реализующие [LoaderInterface](https://github.com/cekta/di/src/ProviderInterface.php).

Иногда для создания зависимости(например \PDO) провайдеру требуются другие зависимости(dsn, username, password, 
options), получение которых может осуществляться другими провайдерами.

В таких случаях провайдер возвращает загрузчик, контейнер получив загрузчик просит его загрузить зависимость передавая 
себя аргументом для разрешения других зависимостей.

### [Autowiring](https://github.com/cekta/di/src/Provider/Autowiring.php)

Это один из провайдеров поставляемых с библиотекой используется для автоматического создания объектов по имени класса.

Он используя **Reflection** анализирует аргументы конструктора и получает имена необходимых зависимостей.

### [Reflection](https://github.com/cekta/di/src/ProviderInterface.php) -

Сервис анализирует конструктор класса определяя имена зависимостей которые необходимы для создания.

Использует ReflectionClass в PHP.

#### Как Reflection определяет имя dependency

1. Если у аргумента указана анотация @inject, используется значение из анотации.
2. Если у аргумента указан тип в виде класса или интерфейса, используется полное имя вместе с namespace (FQCN).
3. Использует имя аргумента, без $ в начале.

Рассмотрим на конкретном примере

```php
<?php

namespace Cekta\DI\DOC\HowItWork;

use \stdClass;

class Example
{
    /**
     * @inject magic $c
     * @param int $a 
     * @param stdClass $b 
     * @param stdClass $c
     */
    public function __construct(
        int $a,
        stdClass $b,
        stdClass $c
    )
    {}
}
```

Зависимости будут определены следующим образом:
1. a - не указана ни анотация, ни тип являющийся классом или интерфейсом.
2. \stdClass - используется полное имя класса или интерфейса.
3. magic - задана анотация что для аргумента $c использовать другую зависимость.

[Compiler]()